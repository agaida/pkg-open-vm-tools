--- a/modules/linux/vsock/linux/af_vsock.c
+++ b/modules/linux/vsock/linux/af_vsock.c
@@ -126,6 +126,7 @@ sys_ioctl(unsigned int fd, unsigned int
 #include "compat_version.h"
 #include "compat_workqueue.h"
 #include "compat_mutex.h"
+#include "compat_kernel_uidgid.h"
 
 #include "vmware.h"
 
@@ -3147,7 +3148,7 @@ __VSockVmciCreate(struct net *net,
       vsk->connectTimeout = psk->connectTimeout;
    } else {
       vsk->trusted = capable(CAP_NET_ADMIN);
-      vsk->owner = current_uid();
+      vsk->owner = from_kuid(&init_user_ns, current_uid());
       vsk->queuePairSize = VSOCK_DEFAULT_QP_SIZE;
       vsk->queuePairMinSize = VSOCK_DEFAULT_QP_SIZE_MIN;
       vsk->queuePairMaxSize = VSOCK_DEFAULT_QP_SIZE_MAX;
--- a/modules/linux/vmhgfs/file.c
+++ b/modules/linux/vmhgfs/file.c
@@ -32,6 +32,7 @@
 #include "compat_fs.h"
 #include "compat_kernel.h"
 #include "compat_slab.h"
+#include "compat_kernel_uidgid.h"
 
 /* Must be after compat_fs.h */
 #if defined VMW_USE_AIO
@@ -656,7 +657,8 @@ HgfsOpen(struct inode *inode,  // IN: In
             iparent = dparent->d_inode;
 
             HgfsSetUidGid(iparent, file->f_dentry,
-                          current_fsuid(), current_fsgid());
+                          from_kuid(&init_user_ns, current_fsuid()),
+                          from_kgid(&init_user_ns,current_fsgid()));
 
             dput(dparent);
          }
--- a/modules/linux/vmhgfs/filesystem.c
+++ b/modules/linux/vmhgfs/filesystem.c
@@ -42,6 +42,7 @@
 #include "compat_string.h"
 #include "compat_uaccess.h"
 #include "compat_version.h"
+#include "compat_kernel_uidgid.h"
 
 #include "filesystem.h"
 #include "transport.h"
@@ -231,13 +232,13 @@ HgfsInitSuperInfo(HgfsMountInfo *mountIn
    if (si->uidSet) {
       si->uid = mountInfo->uid;
    } else {
-      si->uid = current_uid();
+      si->uid = from_kuid(&init_user_ns, current_uid());
    }
    si->gidSet = mountInfo->gidSet;
    if (si->gidSet) {
       si->gid = mountInfo->gid;
    } else {
-      si->gid = current_gid();
+      si->gid = from_kgid(&init_user_ns, current_gid());
    }
    si->fmask = mountInfo->fmask;
    si->dmask = mountInfo->dmask;
--- a/modules/linux/vmhgfs/inode.c
+++ b/modules/linux/vmhgfs/inode.c
@@ -40,6 +40,7 @@
 #include "compat_page-flags.h"
 #include "compat_spinlock.h"
 #include "compat_version.h"
+#include "compat_kernel_uidgid.h"
 
 #include "cpName.h"
 #include "cpNameLite.h"
@@ -488,13 +489,13 @@ HgfsPackSetattrRequest(struct iattr *iat
 
       if (valid & ATTR_UID) {
          attrV2->mask |= HGFS_ATTR_VALID_USERID;
-         attrV2->userId = iattr->ia_uid;
+         attrV2->userId = from_kuid(&init_user_ns, iattr->ia_uid);
          *changed = TRUE;
       }
 
       if (valid & ATTR_GID) {
          attrV2->mask |= HGFS_ATTR_VALID_GROUPID;
-         attrV2->groupId = iattr->ia_gid;
+         attrV2->groupId = from_kgid(&init_user_ns, iattr->ia_gid);
          *changed = TRUE;
       }
 
@@ -591,13 +592,13 @@ HgfsPackSetattrRequest(struct iattr *iat
 
       if (valid & ATTR_UID) {
          attrV2->mask |= HGFS_ATTR_VALID_USERID;
-         attrV2->userId = iattr->ia_uid;
+         attrV2->userId = from_kuid(&init_user_ns, iattr->ia_uid);
          *changed = TRUE;
       }
 
       if (valid & ATTR_GID) {
          attrV2->mask |= HGFS_ATTR_VALID_GROUPID;
-         attrV2->groupId = iattr->ia_gid;
+         attrV2->groupId = from_kgid(&init_user_ns, iattr->ia_gid);
          *changed = TRUE;
       }
 
@@ -1190,7 +1191,8 @@ HgfsMkdir(struct inode *dir,     // IN:
              * a Linux machine and as root, but we might as well give it
              * a go.
              */
-            HgfsSetUidGid(dir, dentry, current_fsuid(), current_fsgid());
+            HgfsSetUidGid(dir, dentry, from_kuid(&init_user_ns, current_fsuid()),
+                                       from_kgid(&init_user_ns, current_fsgid()));
          }
 
          /*
--- a/modules/linux/vmhgfs/fsutil.c
+++ b/modules/linux/vmhgfs/fsutil.c
@@ -36,6 +36,7 @@
 #include "compat_sched.h"
 #include "compat_slab.h"
 #include "compat_spinlock.h"
+#include "compat_kernel_uidgid.h"
 
 #include "vm_assert.h"
 #include "cpName.h"
@@ -639,14 +640,14 @@ HgfsChangeFileAttributes(struct inode *i
     * the server didn't give us a uid or gid.
     */
    if (si->uidSet || (attr->mask & HGFS_ATTR_VALID_USERID) == 0) {
-      inode->i_uid = si->uid;
+      inode->i_uid = make_kuid(&init_user_ns, si->uid);
    } else {
-      inode->i_uid = attr->userId;
+      inode->i_uid = make_kuid(&init_user_ns, attr->userId);
    }
    if (si->gidSet || (attr->mask & HGFS_ATTR_VALID_GROUPID) == 0) {
-      inode->i_gid = si->gid;
+      inode->i_gid = make_kgid(&init_user_ns, si->gid);
    } else {
-      inode->i_gid = attr->groupId;
+      inode->i_gid = make_kgid(&init_user_ns, attr->groupId);
    }
 
    inode->i_rdev = 0;  /* Device nodes are not supported */
@@ -1624,7 +1625,7 @@ HgfsSetUidGid(struct inode *parent,
    struct iattr setUidGid;
 
    setUidGid.ia_valid = ATTR_UID;
-   setUidGid.ia_uid = uid;
+   setUidGid.ia_uid = make_kuid(&init_user_ns, uid);
 
    /*
     * Only set the gid if the host file system wouldn't have for us.  See the
@@ -1632,7 +1633,7 @@ HgfsSetUidGid(struct inode *parent,
     */
    if (!parent || !(parent->i_mode & S_ISGID)) {
       setUidGid.ia_valid |= ATTR_GID;
-      setUidGid.ia_gid = gid;
+      setUidGid.ia_gid = make_kgid(&init_user_ns, gid);
    }
 
    /*
--- /dev/null
+++ b/modules/linux/shared/compat_kernel_uidgid.h
@@ -0,0 +1,223 @@
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,5,0))
+
+#ifndef _LINUX_UIDGID_H
+#define _LINUX_UIDGID_H
+
+#ifndef LINUX_BACKPORT
+#define LINUX_BACKPORT(__sym) backport_ ##__sym
+#endif
+
+/*
+ * A set of types for the internal kernel types representing uids and gids.
+ *
+ * The types defined in this header allow distinguishing which uids and gids in
+ * the kernel are values used by userspace and which uid and gid values are
+ * the internal kernel values.  With the addition of user namespaces the values
+ * can be different.  Using the type system makes it possible for the compiler
+ * to detect when we overlook these differences.
+ *
+ */
+#include <linux/types.h>
+#include <linux/highuid.h>
+
+struct user_namespace;
+extern struct user_namespace init_user_ns;
+
+#ifdef CONFIG_UIDGID_STRICT_TYPE_CHECKS
+
+typedef struct {
+	uid_t val;
+} kuid_t;
+
+
+typedef struct {
+	gid_t val;
+} kgid_t;
+
+#define KUIDT_INIT(value) (kuid_t){ value }
+#define KGIDT_INIT(value) (kgid_t){ value }
+
+static inline uid_t __kuid_val(kuid_t uid)
+{
+	return uid.val;
+}
+
+static inline gid_t __kgid_val(kgid_t gid)
+{
+	return gid.val;
+}
+
+#else
+
+typedef uid_t kuid_t;
+typedef gid_t kgid_t;
+
+static inline uid_t __kuid_val(kuid_t uid)
+{
+	return uid;
+}
+
+static inline gid_t __kgid_val(kgid_t gid)
+{
+	return gid;
+}
+
+#define KUIDT_INIT(value) ((kuid_t) value )
+#define KGIDT_INIT(value) ((kgid_t) value )
+
+#endif
+
+#define GLOBAL_ROOT_UID KUIDT_INIT(0)
+#define GLOBAL_ROOT_GID KGIDT_INIT(0)
+
+#define INVALID_UID KUIDT_INIT(-1)
+#define INVALID_GID KGIDT_INIT(-1)
+
+static inline bool uid_eq(kuid_t left, kuid_t right)
+{
+	return __kuid_val(left) == __kuid_val(right);
+}
+
+static inline bool gid_eq(kgid_t left, kgid_t right)
+{
+	return __kgid_val(left) == __kgid_val(right);
+}
+
+static inline bool uid_gt(kuid_t left, kuid_t right)
+{
+	return __kuid_val(left) > __kuid_val(right);
+}
+
+static inline bool gid_gt(kgid_t left, kgid_t right)
+{
+	return __kgid_val(left) > __kgid_val(right);
+}
+
+static inline bool uid_gte(kuid_t left, kuid_t right)
+{
+	return __kuid_val(left) >= __kuid_val(right);
+}
+
+static inline bool gid_gte(kgid_t left, kgid_t right)
+{
+	return __kgid_val(left) >= __kgid_val(right);
+}
+
+static inline bool uid_lt(kuid_t left, kuid_t right)
+{
+	return __kuid_val(left) < __kuid_val(right);
+}
+
+static inline bool gid_lt(kgid_t left, kgid_t right)
+{
+	return __kgid_val(left) < __kgid_val(right);
+}
+
+static inline bool uid_lte(kuid_t left, kuid_t right)
+{
+	return __kuid_val(left) <= __kuid_val(right);
+}
+
+static inline bool gid_lte(kgid_t left, kgid_t right)
+{
+	return __kgid_val(left) <= __kgid_val(right);
+}
+
+static inline bool uid_valid(kuid_t uid)
+{
+	return !uid_eq(uid, INVALID_UID);
+}
+
+static inline bool gid_valid(kgid_t gid)
+{
+	return !gid_eq(gid, INVALID_GID);
+}
+
+#ifdef CONFIG_USER_NS
+
+#define make_kuid LINUX_BACKPORT(make_kuid)
+extern kuid_t make_kuid(struct user_namespace *from, uid_t uid);
+#define make_kgid LINUX_BACKPORT(make_kgid)
+extern kgid_t make_kgid(struct user_namespace *from, gid_t gid);
+
+#define from_kuid LINUX_BACKPORT(from_kuid)
+extern uid_t from_kuid(struct user_namespace *to, kuid_t uid);
+#define from_kgid LINUX_BACKPORT(from_kgid)
+extern gid_t from_kgid(struct user_namespace *to, kgid_t gid);
+#define from_kuid_munged LINUX_BACKPORT(from_kuid_munged)
+extern uid_t from_kuid_munged(struct user_namespace *to, kuid_t uid);
+#define from_kgid_munged LINUX_BACKPORT(from_kgid_munged)
+extern gid_t from_kgid_munged(struct user_namespace *to, kgid_t gid);
+
+#define kuid_has_mapping LINUX_BACKPORT(kuid_has_mapping)
+static inline bool kuid_has_mapping(struct user_namespace *ns, kuid_t uid)
+{
+	return from_kuid(ns, uid) != (uid_t) -1;
+}
+
+#define kgid_has_mapping LINUX_BACKPORT(kgid_has_mapping)
+static inline bool kgid_has_mapping(struct user_namespace *ns, kgid_t gid)
+{
+	return from_kgid(ns, gid) != (gid_t) -1;
+}
+
+#else
+
+#define make_kuid LINUX_BACKPORT(make_kuid)
+static inline kuid_t make_kuid(struct user_namespace *from, uid_t uid)
+{
+	return KUIDT_INIT(uid);
+}
+
+#define make_kgid LINUX_BACKPORT(make_kgid)
+static inline kgid_t make_kgid(struct user_namespace *from, gid_t gid)
+{
+	return KGIDT_INIT(gid);
+}
+
+#define from_kuid LINUX_BACKPORT(from_kuid)
+static inline uid_t from_kuid(struct user_namespace *to, kuid_t kuid)
+{
+	return __kuid_val(kuid);
+}
+
+#define from_kgid LINUX_BACKPORT(from_kgid)
+static inline gid_t from_kgid(struct user_namespace *to, kgid_t kgid)
+{
+	return __kgid_val(kgid);
+}
+
+#define from_kuid_munged LINUX_BACKPORT(from_kuid_munged)
+static inline uid_t from_kuid_munged(struct user_namespace *to, kuid_t kuid)
+{
+	uid_t uid = from_kuid(to, kuid);
+	if (uid == (uid_t)-1)
+		uid = overflowuid;
+	return uid;
+}
+
+#define from_kgid_munged LINUX_BACKPORT(from_kgid_munged)
+static inline gid_t from_kgid_munged(struct user_namespace *to, kgid_t kgid)
+{
+	gid_t gid = from_kgid(to, kgid);
+	if (gid == (gid_t)-1)
+		gid = overflowgid;
+	return gid;
+}
+
+#define kuid_has_mapping LINUX_BACKPORT(kuid_has_mapping)
+static inline bool kuid_has_mapping(struct user_namespace *ns, kuid_t uid)
+{
+	return true;
+}
+
+#define kgid_has_mapping LINUX_BACKPORT(kgid_has_mapping)
+static inline bool kgid_has_mapping(struct user_namespace *ns, kgid_t gid)
+{
+	return true;
+}
+
+#endif /* CONFIG_USER_NS */
+
+#endif /* _LINUX_UIDGID_H */
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(3,5,0) */
